#!/bin/bash
#
#   CDM: The Console Display Manager
#
#   Copyright (C) 2009-2012, Daniel J Griffiths <dgriffiths@ghost1227.com>
#   Thanks to:
#
#       Andrwe          beta-testing and submitting the fix for the all
#                       important X incrementation function
#       brisbin33       code cleanup
#       tigrmesh        finding a critical issue with the gnome-session handler
#       Profjim         several incredibly useful patches
#       lambchops468    hibernation patches
#       CasperVector    Massive rearchitecturing and code sanitation
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#   
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#   
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#   MA 02110-1301, USA.

name=$(basename "$0")
longname='Console Display Manager'
ver='0.8'

trap '' SIGINT SIGTSTP

# Helper functions.
warn() { (printf ' \033[01;33m*\033[00m '; echo "$name: $*") > /dev/stderr; }
error() { (printf ' \033[01;31m*\033[00m '; echo "$name: $*") > /dev/stderr; }
exitnormal() { exit 0; }
exiterror() { sleep 1; exit 1; }

# Source cdm configurations.
# shellcheck disable=SC1090
if [[ -n "$1" ]]; then
    if [[ -f "$1" ]]
    then
        source "$1"
    else
        error "config file \`$1' does not exist."
        exiterror
    fi
elif [[ -f "$HOME/.cdmrc" ]]; then
    source "$HOME/.cdmrc"
elif [[ -f "${XDG_CONFIG_HOME:-$HOME/.config}/cdm/cdmrc" ]]; then
    source "${XDG_CONFIG_HOME:-$HOME/.config}/cdm/cdmrc"
elif [[ -f /etc/cdmrc ]]; then
    # shellcheck disable=SC1091
    source /etc/cdmrc
fi

# Default options.
CDM_SESSIONS_DIR="${CDM_SESSIONS_DIR:-${XDG_DATA_HOME:-${HOME}/.local/share}/xsessions}"
CDM_SESSIONS_DIR_FALLBACK="${CDM_SESSIONS_DIR_FALLBACK:-/usr/share/xsessions}"
countfrom=${countfrom:-0}
display=${display:-0}
xtty=${xtty:-7}
locktty=${locktty:-false}
altstartx=${altstartx:-false}
startxlog="${startxlog:-/dev/null}"
[[ -z "${binlist[*]}" ]] && binlist=()
[[ -z "${namelist[*]}" ]] && namelist=()
[[ -z "${flaglist[*]}" ]] && flaglist=()
[[ -z "${serverargs[*]}" ]] && serverargs=(-nolisten tcp)

# Offer all available sessions in /etc/X11/Sessions,
# if $binlist if not explicitly set in cdmrc.
if [[ "${#binlist[@]}" == 0 && -d /etc/X11/Sessions ]]; then
    binlist=($(find /etc/X11/Sessions -maxdepth 1 -type f))
    flaglist=($(sed 's/[[:digit:]]\+/X/g' <<< ${!binlist[@]}))
    namelist=(${binlist[@]##*/})
fi

# If $binlist is not set in cdmrc or by files in /etc/X11/Sessions,
# try .desktop files in /usr/share/xsessions/ .

if [ "${#binlist[@]}" -eq 0 ]; then
    _config_location="${CDM_SESSIONS_DIR}"
    desktopsessions=()
    if [ "${#desktopsessions[@]}" -eq 0 ] && [ -e "${_config_location}" ]; then
        desktopsessions=($(find "${_config_location}" -name '*.desktop'))
    fi
    _config_location="${CDM_SESSIONS_DIR_FALLBACK}"
    if [ "${#desktopsessions[@]}" -eq 0 ] && [ -e "${_config_location}" ]; then
        desktopsessions=($(find "${_config_location}" -name '*.desktop'))
    fi
    #TODO: allow full quoting and expansion according to desktop entry spec:
    # http://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#exec-variables

    for ((count=0; count < ${#desktopsessions[@]}; count++)); do
        # TryExec key is there to determine if executable is present,
        # but as we are going to test the Exec key anyway, we ignore it.
        execkey=$(sed -n -e 's/^Exec=//p' <${desktopsessions[${count}]})
        namekey=$(sed -n -e 's/^Name=//p' <${desktopsessions[${count}]})
        if [[ -n ${execkey} && -n ${namekey} ]]; then
            # The .desktop files allow there Exec keys to use $PATH lookup.
            binitem="$(which $(cut -f 1 -d ' ' <<< ${execkey}))"
            # If which fails to return valid path, skip to next .desktop file.
            if [ $? -ne 0 ]; then continue; fi
            is_terminal=$(sed -n -e 's/^Terminal=//p' <${desktopsessions[${count}]})
            if [ "${is_terminal}" = 'true' ]; then
                _type='C'
            else
                _type='X'
            fi
            binlist+=("${binitem} $(cut -s -f 2- -d ' ' <<< ${execkey})")
            flaglist+=("${_type}")
            namelist+=("${namekey}")
        fi
    done
fi

case "${#binlist[@]}" in
    0)
        error "No programs found in cdm config file, /etc/X11/Sessions or /usr/share/xsessions."
        binlist=('bash --login')
        namelist=('bash')
        flaglist=(C)
        binindex=0
        ;;
    1)
        # only one possible program
        binindex=0
        ;;
    *)
        select value in "${namelist[@]}"; do
            for i in "${!namelist[@]}"; do
               if [[ "${namelist[$i]}" = "${value}" ]]; then
                  binindex="${i}";
                  break 2
               fi
            done
        done
        (( binindex-=countfrom ))
        ;;
esac

# Run $bin according to its flag.
bin=($(eval echo "${binlist[${binindex}]}"))
case ${flaglist[$binindex]} in
    # *C*onsole programs.
    [Cc])
        # If $bin is a login shell, it might `exec' cdm again, causing an endless
        # loop. To solve this problem, export $CDM_SPAWN when `exec'ing $bin and
        # only let the shell automatically `exec' cdm when $CDM_SPAWN is not set.
        # See also the example shell profile file shipped with the cdm package.

        # Also untrap SIGINT and SIGTSTP before spawning process: If this is not
        # done, any child process of any child (bash) shell will completely
        # ignore SIGINT, which is rather confusing, and cannot be undone.
        trap - SIGINT SIGTSTP
        CDM_SPAWN=$$ exec "${bin[@]}"
        ;;

    # *X* programs.
    [Xx])
        # If X is already running and locktty=true, activate it.
        if ${locktty} && xdpyinfo -display ":$display.0" &> /dev/null; then
            chvt "$((display+xtty))"
            exitnormal
        fi

        # Get the first empty display.
        display=0
        while ((display < 7)); do
            if dpyinfo=$(xdpyinfo -display ":$display.0" 2>&1 1>/dev/null) ||
                # Display is in use by another user.
                [[ "$dpyinfo" == 'No protocol specified'* ]] ||
                # Invalid MIT cookie.
                [[ "$dpyinfo" == 'Invalid MIT'* ]]
            then
                (( display+=1 ))
            else
                break
            fi
        done

        # Support for running X in current tty.
        if [[ $xtty == 'keep' ]]; then
            vt="$(tty)"
            if [[ "$vt" != '/dev/tty'* ]]; then
                error 'invalid TTY.'
                exiterror
            fi
            vt="${vt#/dev/tty}"
        else
            vt="$((xtty+display))"
        fi

        serverargs=(":${display}" "${serverargs[@]}" "vt$vt")

        if (if ${altstartx}; then
            # Alternative method of calling setsid(/startx) for systems that are unresponsive to the 'normal' call.
            (setsid startx "${serverargs[@]}" > "${startxlog}" 2>&1 &)
        else
            setsid startx "${serverargs[@]}" > "${startxlog}" 2>&1 &
        fi)
        then
            exitnormal
        else
            warn "'setsid startx' exited unsuccessfully."
            exiterror
        fi
        ;;

    *)
        error "unknown flag: \`${flaglist[$binindex]}'."
        exiterror
        ;;
esac

# vim:ts=4:sw=4:et
